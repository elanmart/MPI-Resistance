Zadanie:
	Procesy ułożone w pseudo-drzewo: każdy ma jednego rodzica, kilka dzieci, oraz sąsiadów.
	Sąsiedzi danego pocesu: przyjąłem że sąsiadów losujemy na całym poziomie drzewa. Można łatwo zmienić żeby losować tylko wśród dzieci danego node'a: tak, żeby sąsiedzi mieli wspólnego rodzica
	
	Co ma się dziać:
		Proces może zarządać spotkania. 
		Wtedy musi zebrać kilku kumpli (sąsiedzi, dzieci, parent), zebrać zasób i uzyskać zgodę akceptora.
		Jest kilku akceptorów w całym drzewie, losowo mogą przekazywać tę rolę dzieciom / sąsiadom / parentowi.
		Oprócz tego należy zdobyć zasób. Zasobów jest kilka sztuk w drzewie, musimy zgłosić potrzebę i otzymać zasób od innego noda.
		
		Komunikacja w drzewie wygląda następująco: 
			Każdy proces ma swojego Managera. Manager zajmuje się serializacją wiadomości i napierdalaniem ich po MPI. 
			Wysyłane są struktury Message. Message ma dwa pola używane przez MPI: __to__ i __from__
			Oprócz tego ma kilka pól takich jak ID wysyłającego oraz ID odbiorcy docelowego (-1 to wszyscy). 
			Kluczowe jest pole "word", bo to tam jest przechowywane info o tym, co dana wiaodomość oznacza.
			Kiedy proces chce coś nadać, wpisuje w pole "desination" ID odbiorcy i robi funkcję broadcast. Broadcast nadaje tę wiadomość do dzieci , sąsiadów i parenta w nadziei, że zostanie ona rozpropagowana po całym drzewie i w końcu trafi do "destination".
			Każdy proces ma cache wiadomości które już widział. Jak trafi do niego drugi raz to samo, to olewa i nic nie robi. 
			Jak zobaczy coś, czego nie widział, to sprawdza, czy to do niego, czy może trzeba broadcastować dalej w drzewo.
			Manager zajmuje sę tym żeby nie broadcastować do tego samego noda, co przysłał daną wiadomość. 
					
		Najprostsze jest pozyskiwanie resorsa:
			Budujemy message gdzie Word = RESOURCE_REQUEST, destination = "ALL". Wysyłamy w drzewo. 
			Każdy, kto ma dostępny resource, blokuje go i odpowiada nam "mam resors, chcesz"?
			Odpowiadamy "tak, chcę" pierwszemu nodowi który zgłosił że ma resors. Reszcie wysyłamy "jednak nie" żeby sobie odblokowały resors.
			https://github.com/elanmart/MPI-Resistance/blob/master/src/node.cc#L104
			tu se popacz.
			
			To działa
			
		Później, zebranie kumpli:
			To jest trochę trudniejsze.
			Załóżmy, że proces tworzy set "ID_z_ktorymi_moge_sie_spotkac" = {dzieci, sąsiedzi, parent}. 
			Załóżmy, że każdy proces ma tylko jeden żeton "TAK".
			W najprostszej wersji proces pyta dzieci,sąsi.,parenta: chcecie się spotkać? I czeka na tyle odpowiedzi, ile wysłał pytań.
			Jeżeli zapytany node ma przy sobie żeton "TAK", to wysyła go do procesu pytającego. 
			Proces który inicjuje spotkanie zlicza zetony "TAK", i jeżeli są powyżej tresholda, to zaczyna spotkanie.
			
			OK, spoko. A co jeżeli procesy p1 i p2 są sąsiadami (p1--p2), i oba zaczną inicjować spotkanie?
			Co jeżeli p1--p2 i p2--p3, i wszyscy oni w trójkę zaczną inicjować?
			
			Wersja prosta: 
				Inicjator nigdy nie odpowiada "TAK". Jak ktoś zostanie zapytany przez dwóch inicjatorów, to ma tylko jeden token, więc też bez problemów. 
			
			Wersja PRO:
				Zbieramy tajmstampy kiedy wysłaliśmy każde "TAK" do innych inicjatorów i kiedy dostaliśmy request od innych inicjatorów.
				Ustawiamy te wysłane / odebrane wiadomości w kolejkę. 
				Jeżeli na górze jest odebrane zapytanie, to czekamy na prośbę mergowania.
				Jeżeli na górze jest wysłane zapytanie, to wysyłamy prośbę mergowania. 
				
				Mergowanie polega na tym, że procesy wymieniają się listą swoich kumpli i sprawdzają, czy się pokrywają.
				Np. p1 i p2 oba znają (A, B, C). To jak p1 zebrał {A, B}, a p2 zebrał {C}, to wszystko gra.
				Ale jak p1 zna tylko {A, B}, to jak mu p2 powie, że chce się spotkać z C, to p1 powie "spierdalaj nie znam go, idę się spotykać ze swoimi a ty ze swoimi".
				
				Ten proces można powtarzać, za każdym mergem zawężając ID procesów, które akceptujemy.
				
		
		Akceptacja:
			Przekazanie akceptacji:
				Każdy akceptor ma zestaw struktur do przechowywania rzeczy (jakieś kolejki, cache, tablice, chuje muje, dzikie węże).
				Zwykły proces tego nie ma. 
				
				Więc jak akceptor chce się pozbyć sowjej mocy, to losuje kumpla i mówi mu "CHCESZ_ACCEPTOR_?"
				Tamten odpowiada "TAK"
				Ja odpowiadam "OK_TO_ZAINICJUJ_SOBIE_TABLICE_ZEBY_NAM_ZADEN_MESSAGE_NIE_UMKNAL_I_ZBIERAJ_WSZYSTKO_JAKBYS_BYL_AKCEPTOREM"
				I on na to "OKI :)))"
				I ja na to: "TO_TU_MASZ_WSZYSTKIE_MOJE_DANE_DOŁĄCZ_JE_DO_TEGO_CO_ZEBRAŁEŚ_W_MIĘDZYCZASIE"
				A on na to: "OKI_DZIENKI_TO_OD_TERAZ_JA_AKCEPTUJE"
				
			Uzyskiwanie akceptacji:
				Proces wysyła "CHCE_SIE_SPOTKAC_Z_N_PROCESAMI" + ile jest równe N
				Ta wiadomość idzie w całe drzewo. Jest na niej tajmstamp.
				
				Akceptor ma kolejke priorytetową takich wiadomości, gdzie kluczem jest tajmstamp. 
				Po otrzymaniu wiadomości wrzuca ją w tę kolejkę i wysyła w całe drzewo "AKCEPTOR_OTRZYMAŁ_REQUEST". Wpisuje w tę wiadomość swoje ID, ID requestu, oraz tajmstamp otrzymania.
				Super :))))))
				
				
				Czyli teraz każdy trzyma kolejkę próśb o spotkanie. Do każdej prośby dołącza sobie info o tym, kiedy inni akceptorzy odebrali ten sam request.
				Jeżeli:
					- Na początku kolejki jest Prośba, dla której zebrałem potwierdzenia od wszystkich innych
					- I moje potwierdzenie ma najwcześniejszy tajmstamp
					- To wysyłam do Proszącego akceptację na spotkanie. 
				Nie muszę nawet wysyłać info do innych procesów. One widzą, że ich tajmstamp odebrania Prośby nie jest najmniejszy, więc założą po prostu, że ktoś inny to obsłużył. 
				Proszący musi tylko wyemitować message "DONE", żeby procesy zbiły sobie licznik który mówi, ile spotkań ma miejsce w danej chwili. 
				
				OKI, czyli jak w zasadzie rozwiązujemy problem z tym, że proces musi wiedzieć, ile spotkań już się odbywa, żeby móc udzielić zgode?
				Po prostu zakładamy, że każda Prośba z wcześniejszym tajmstampem niż to, co chcemy obsłużyć, została już obsłużona i dekrementujemy liczniki. 
				Dopiero jak przyjdzie "KONIEC" powiązany z tą prośbą, o usuwamy ją z kolejki. 
				
				IMO ten prosty algos rozwiązuje wszystkie problemiki jakie mogą powstać :))))
				
				Powiedz co myślisz :)))))
